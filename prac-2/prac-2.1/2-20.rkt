;; +, *, list 같은 프로시저에서는 인자의 수가 정해지지 않는다. 그런 프로시저
;; 를 정의하는 방법 가운데 하나는, 꼬리점 문법(dotted-tail notation)을 쓰는 것이다.
;; 이 문법으로 프로시저를 정의할 때에는, 마지막 인자 이름 앞에 '.'이 찍힌 인자
;; 리스트를 받는다. 이때 이 문법이 뜻하는 바는, 이렇게 정의된 프로시저를
;; 불러 썼을 때, 첫 번째 인자(parameter)는 다른 프로시저와 다를 바 없이 첫 번째
;; 인자 값(argument)으로 맞바뀐다는 것이다. 그러나 마지막 인자는 남아 있는 인자들의
;; 리스트가 된다. 그 보기로, 다음과 같은 프로시저 정의가 있다고 하자.
;;
;; (define (f x y . z) <body>)
;;
;; 프로시저 f는 인자를 두 개 이상 받을 수 있다.
;;
;; (f 1 2 3 4 5 6)
;;
;; 이 경우에, f의 몸에서 x는 1로, y는 2로, z는 리스트 (3 4 5 6)의 값으로 맞바뀐다.
;; 또, 다음과 같은 정의가 있다고 하자.
;;
;; (define (g . w) <body>)
;;
;; 이때, 프로시저 g는 인자를 0개 이상으로 받을 수 있다.
;;
;; (g 1 2 3 4 5 6)
;;
;; g의 몸에서 w는 리스트 (1 2 3 4 5 6)의 값을 받는다.
;; 이 문법을 써서, 하나 이상의 정수를 인자로 받아, 첫 번째 인자가 짝수라면
;; 짝수 원소만, 홀수라면 홀수 원소만 들어 있는 리스트를 결과로 내놓는 프로시저
;; same-parity를 짜보라. 이 프로시저에 다음 인자 값을 건네어 계산하면, 그 아래에
;; 있는 결과가 나온다.
;;
;; (same-parity 1 2 3 4 5 6 7)
;; (1 3 5 7)
;;
;; (same-parity 2 3 4 5 6 7)
;; (2 4 6)

(define (same-parity f . z)
  (define (filter-list p lst)
    (cond ((null? lst) null)
          ((p (car lst)) (cons (car lst) (filter-list p (cdr lst))))
          (else (filter-list p (cdr lst)))))
  (cons f (filter-list (if (even? f)
                           even?
                           odd?)
                       z)))
