;; for-each 프로시저는, map처럼 프로시저와 리스트를 하나씩 인자로 받지만,
;; 결과 값으로 리스트를 내놓는 게 아니라, 리스트의 원소마다 (왼쪽에서 오른
;; 쪽으로) 프로시저를 적용한 결과만 내놓는다. 원소마다 프로시저를 적용했을 때
;; 얻은 값은 아예 쓰지 않는다. 그러므로 리스트의 원소를 차례대로 화면에 찍는
;; 등 똑같은 명령을 처리해야 하는 프로시저를 짜는 데 쓴다. 아래는 그 보기다.
;;
;; (for-each (lambda (x) (newline) (display x))
;;           (list 57 321 88))
;;
;; 57
;; 321
;; 88
;;
;; (위에 나타나지 않았지만) for-each 프로시저의 결과 값은 (참처럼) 뭐가 되어도
;; 상관없다. 그러니, for-each 프로시저를 정의해 보라.

(define (for-each f items)
  (cond ((null? items) null)
        (else (f (car items))
              (for-each f (cdr items)))))
