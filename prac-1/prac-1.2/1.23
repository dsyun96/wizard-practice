앞에서 작성한 smallest-divisor 프로시저에서, 쓸모없는 연산을 하는 것을 알 수 있다.
검사하려는 수가 2로 나누어 떨어지지 않는 것을 확인했다면 2보다 큰 짝수로는 나누어 떨어지지 않을 것이기 때문에 짝수를 검사할 필요가 없는 것이다.
따라서 2, 3, 4, 5, 6, ...이 아니라 2, 3, 5, 7, 9, ...로 검사해야한다.
이렇게 최적화했을 경우 2배보다 더 빨라지는가?
연습문제 1.22에서 구한 소수 12개로 확인해보라.

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
        
(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

1009 -> 3.159611 -> 2.734224
1013 -> 3.591026 -> 2.709179
1019 -> 3.336812 -> 2.704864

10007 -> 10.35747 -> 7.52599
10009 -> 10.83656 -> 8.17669
10037 -> 10.8567  -> 8.16449

100003 -> 32.42367 -> 21.45609
100019 -> 33.29672 -> 21.89913
100043 -> 34.11773 -> 23.04181

1000003 -> 106.0203 -> 68.4742
1000033 -> 112.2258 -> 76.4021
1000037 -> 107.4948 -> 74.9289


(/ (/ (+ 3.159611 3.591026 3.336812) 3)
   (/ (+ 2.734224 2.709179 2.704864) 3))

(/ (/ (+ 10.35747 10.83656 10.8567) 3)
   (/ (+ 7.52599 8.17669 8.16449) 3))

(/ (/ (+ 32.42367 33.29672 34.11773) 3)
   (/ (+ 21.45609 21.89913 23.04181) 3))

(/ (/ (+ 106.0203 112.2258 107.4948) 3)
   (/ (+ 68.4742 76.4021 74.9289) 3))

Result:
1.2379870468162124
1.342879361063754
1.5036534013644887
1.4819526562610894



2배로 빨라지지 않는 것을 확인할 수 있다. 
이는 아마 (next test-divisor) 라는 프로시저를 호출하고, 그 안에서 if로 다시 조건 분기가 발생하는 과정 때문이라고 생각되는데, 정말로 그런지 확인하기 위해 (next test-divisor) 프로시저를 호출하는 위치에 그대로 몸체를 작성해보자.

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor
               n
               (if (= test-divisor 2)
                   3
                   (+ test-divisor 2))))))


1009 -> 3.159611 -> 2.734224 -> 1.937415
1013 -> 3.591026 -> 2.709179 -> 1.949969
1019 -> 3.336812 -> 2.704864 -> 1.99722

10007 -> 10.35747 -> 7.52599 -> 6.36171
10009 -> 10.83656 -> 8.17669 -> 6.81128
10037 -> 10.8567  -> 8.16449 -> 6.61974

100003 -> 32.42367 -> 21.45609 -> 18.0613
100019 -> 33.29672 -> 21.89913 -> 18.84551
100043 -> 34.11773 -> 23.04181 -> 19.41511

1000003 -> 106.0203 -> 68.4742 -> 59.0506
1000033 -> 112.2258 -> 76.4021 -> 67.1739
1000037 -> 107.4948 -> 74.9289 -> 67.563

Result:
1.7142103359886238
1.6193183052565263
1.7726334613592718
1.6809180158678962



좀 더 2배에 가까워졌다. 여기서 우리는 소수만으로 테스트하기 때문에 아예 if를 걷어내보자.

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor
               n
               (+ test-divisor 2)))))


1009 -> 3.159611 -> 2.734224 -> 1.937415 -> 1.813632
1013 -> 3.591026 -> 2.709179 -> 1.949969 -> 1.779633
1019 -> 3.336812 -> 2.704864 -> 1.99722  -> 1.869113

10007 -> 10.35747 -> 7.52599 -> 6.36171 -> 5.51036
10009 -> 10.83656 -> 8.17669 -> 6.81128 -> 5.53132
10037 -> 10.8567  -> 8.16449 -> 6.61974 -> 5.49539

100003 -> 32.42367 -> 21.45609 -> 18.0613  -> 16.97364
100019 -> 33.29672 -> 21.89913 -> 18.84551 -> 17.66943
100043 -> 34.11773 -> 23.04181 -> 19.41511 -> 17.42614

1000003 -> 106.0203 -> 68.4742 -> 59.0506 -> 44.8561
1000033 -> 112.2258 -> 76.4021 -> 67.1739 -> 48.1707
1000037 -> 107.4948 -> 74.9289 -> 67.563  -> 48.8816


Result:
1.8467138304965347
1.9381141883054256
1.9174118447351132
2.2954307144608777



2배에 상당히 근접한 결과다. 이 정도면 2배에서 플마 오차 정도로 볼 수 있다.

